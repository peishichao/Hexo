---
title: 对于计算机开机过程的一些看法
date: 2016-09-08 19:25:00
categories: 技术分享
tags:
- 操作系统
- 计算机
- 开机过程
- 看法
---

![](http://i1.piimg.com/567571/76e4a9900a7717ae.png)

<!-- more -->

对于大多数学计算机或者是非科班出身的童鞋，大多对于计算机的开机过程大致只了解到按下计算机电源开关的程度。我们对于计算机到底是如何开启的，如何`boot`的，了解的并不是很多。今天我就这些问题做一些小小的探讨。说的不对或者不好的地方尽情拍砖...

#### 系统引导

其实对于操作系统我们有太多的未知。只能说前人实在是太腻害了。我们从按下计算机开关的那一刻开始慢慢的捋一捋思绪。

首先借鉴[阮一峰的网络日志](http://www.ruanyifeng.com/blog/2013/02/booting.html)中的一个问题：`boot`怎么理解？

`boot`原本为靴子的意思。启动和靴子的关系是什么呐...这就扯到一门谚语了：

> `"pull oneself up by one's bootstraps"`

中文解释为：拽着鞋带把自己提起来。有点常识的童鞋都知道这是不可能的。这和计算机的启动过程其实有相似的地方：必须首先运行程序才可以启动计算机，但是计算机不启动就无法运行程序。好矛盾..好纠结是不是...

上述烧脑问题解答：操作系统是由进程叠加而成的。然而进程是由进程创建而来。进程由进程创建而来..而来..来...所以万事必有一个根才可以。否则就陷入了无限循环的哲学问题了。所以，对于进程来说，规定了进程0为所有进程的上帝。进程0创建了进程1，进而一而再再而三的创建其他进程。所以，对于计算机启动而言也一定有相同的体系。首先我们必须要硬性规定一个起始程序。目前，我们通过探讨已经知道必须首先启动一个程序了。然而我们怎么启动这个程序那？想要启动一个程序，首先必须将这个程序装入内存吧...我们怎么才能把这个起始程序装入内存呐..这就回到了问题的关键--系统引导。

我们把：从用户按下计算机电源开关开始，到操作系统运行起来这段时间被称为“系统引导”。由上文可知，其实引导过程对于操作系统来说是至关重要的一环。因为木有引导，操作系统无法运行。

那么问题又来了：当我们按下计算机电源开关之后，到底是谁在工作那？这里我们又要贯穿一下计算机硬件相关的知识了==（[寄存器相关](http://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html)）。

**CS 寄存器 和 IP 寄存器：**

CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中  CS  为代码段寄存器，而   IP  为指令指针寄存器 。

那么问题又来了：什么叫做指示了 CPU 当前将要读取的指令呢？在 8086  CPU 中，为什么  CPU  会自动的执行指令呢？

这些指令肯定是存放在内存中的，但是  CPU  怎么知道这些指令存放在内存的那个位置呢？

比如，我有下面的两条指令要执行：

```
    MOV AX,1234H
    MOV BX,AX
```

而假设这两条指令在内存中存放为：

![](http://i4.buimg.com/567571/47976157fd6ff294.png)

很显然， 1000H:0000H 指向的是  MOV  AX，1234H  的首地址，如果 CPU 要读取到我的指令的话，很显然，必须要知道地址  1000H:0000H ，然后  CPU  就可以根据这个首地址，将汇编指令**MOV  AX，1234H**  所对应的机器码读入到  CPU  的指令寄存器中，最后便可以在  CPU  中进行处理了。

但关键是   CPU  如何知道我的  1000H:0000H  这个首地址？其实这就需要使用到  CS:IP  这个寄存器组了 。当我们运行一个可执行文件时，很明显，我们需要另外一个程序来将这个可执行文件加载到内存当中，关于这个加载可执行文件的程序，我们在这里不管他，点一下即可，一般是通过操作系统的外壳程序（也就是传说中的  Shell  程序），Shell  将可执行文件加载到内存中以后，就会设置  CPU  中的两个寄存器，即设置  CS:IP  两个寄存器指向可执行文件的起始地址，此后  CPU  便从这个起始地址开始读取内存中的指令，并且执行，比如我们在写汇编程序时，通常会使用  START  标记，其实这个标记就是用来标记起始地址的，当将一个汇编程序编译，连接成可执行文件以后，再通过操作系统的  Shell  程序将可执行文件加载到内存中以后，这个  START  所标记处的地址就是整个可执行文件的起始地址了 。

**也就是说，当一个可执行文件加载到内存中以后，CS:IP  两个寄存器便指向了这个可执行文件的起始地址，然后CPU  就可以从这个起始地址开始往下读取指令，当读取完指令后，CS:IP  将会自动的改变，基本上是改变  IP ，从而指向下一条要读取的指令，这样就可以执行这个可执行文件了 。**

**最后再对  CS:IP  总结一下：**

1. 你想让  CPU  执行哪行指令，你就让  CS:IP  指向保存有指令的那块内存即可。
2. 任何时候，CS:IP  指向的地址中的内容都是  CPU  当前执行的指令。

通过上述了解CS 和 IP 寄存器之后，我们就可以探索下面的问题了。

在用户按下计算机电源开关之后，CPU会自动的将其CS寄存器设定为0xFFFF，将其IP寄存器设定为0x0000。由于CS:IP指出了下一条指令的地址，因此CPU会跳到0xFFFF:0x0000处进行执行。为什么是这个地址而不是其它地址呢？这其实是一个很巧妙的设计。

我们接下来以8086为例，8086是16位的CPU，但是却有20根地址线。也就是说可以寻址2的20次幂=1M内存空间。（2的10次幂=1K，2的32次幂=4G，2的30次幂=1G）这段内存空间由RAM、ROM组成。ROM是随机自读存储器，里面的程序是在计算机出厂的时候直接烧死在里面的。**它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息。**其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。被称为BIOS（"Basic Input Output System"-基本输入输出系统）。 不同的硬件厂商这段程序也会随着机型的不同而不同。

正是因为这个原因：有可能A厂出产的计算机所带的这段程序的大小为1K，而B厂出产的这段程序的大小为2K。

如果将这段程序放在0x0000处，那么用户写的程序就可能从0x0400处开始也可能从 0x0800处开始，非常不统一。故而，将此段程序放在1M内存的顶部，那么用户写的程序就都可以从0x0000处开始了。

但将BIOS这段程序放在1M内存的顶部，如果这段程序大小为1K，那么应当从0xFFC00开始放。如果这段程序的大小为2K，那么应当从0xFF800开始放，对于CPU而言，到底是应当从0xFFC00开始执行还是应当从0xFF800开始执行呢？为了解决这个问题，8086规定，CPU均从0xFFFF0处开始执行，而在0xFFFF0处，放一条无条件转移指令JMP。如果A厂的BIOS是从0xFFC00开始放的，那么这条转移指令就跳转到0xFFC00处开始执行。如果B厂的BIOS是从0xFF800开始放的，那么这条转移指令就跳转到0xFF800处开始执行，各个厂家可以跟据自己所生产的BIOS程序的大小，来决定此转移指令具体跳转到的位置。

　这里有一点需要清楚的是，通常认为，内存编址是连续的，不会出现空洞，其实完全不是这样。比如，假设BIOS的编址是从 0xF0000开始，而RAM，即通常讲的内存编址是从0x00000开始，那么，如果用户只安装了32K内存，那么内存的编址范围就是 0x00000~0x07FFF，那么从0x08000至0xEFFFF处就没有安装内存，这就是一个内存空洞。

当CPU执行了放在0xFFFF0处的第一条指令后，就跳转到BIOS程序内部去执行了，下面就来看看BIOS都做了些什么。

BIOS的工作相当简单，主要的工作就是执行主机自检（POST）。

如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示CPU、内存、硬盘灯信息。

自检完成后，然后查找操作系统存在在哪个磁盘上，将操作系统载入。BIOS需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做“启动顺序”。BIOS在查找各磁盘的操作系统时，主要是查找磁盘上的第一个扇区（0面0磁道1扇区），每个扇区是512字节，如果这是一个引导扇区，那么就将它载入0x7C00的内存地址 上，然后跳转到此地址上执行。如果此不是一个引导扇区，就继续查找下一个磁盘，看其上面是否存在引导扇区。如果所有的磁盘上都不存在引导扇区，则在屏幕上 打印出一条出错信息。（如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。）

这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。

| 情况分类      | 情况分析                                     |
| --------- | ---------------------------------------- |
| 卷引导记录     | 四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做"卷引导记录"。"卷引导记录"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。 |
| 扩展分区和逻辑分区 | 计算机先读取扩展分区的第一个扇区，叫做"扩展引导记录"。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。<很少用这种方式> |
| 启动管理器     | 计算机读取"主引导记录"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的["启动管理器"](http://en.wikipedia.org/wiki/Boot_loader#Modern_boot_loaders)（boot loader），由用户选择启动哪一个操作系统。Linux环境中，目前最流行的启动管理器是[Grub](http://en.wikipedia.org/wiki/GNU_GRUB) |

　引导扇区只有一扇区即512字节大，因此它的主要目的是把操作系统的内核读进内存，然后跳转到操作系统内核处开始执行。从编写操作系统角度来说，前面的CPU上电及BIOS的工作都不是操作系统能控制的，而从引导扇区开始，就完完全全可由操作系统来控制了，因此，编写引导扇区也是编写操作系统必要的工作之一。从BIOS跳入引导扇区后，计算机系统引导工作就算完成，怎样把操作系统内核读进内存，然后再安排一条跳转指令跳到内核处执行就是操作系统开发人员的工作了。

------

512字节的主引导记录：

```
　　（1） 第1-446字节：调用操作系统的机器码。
　　（2） 第447-510字节：分区表（Partition table）。
　　（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
```

硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，"主引导记录"因此必须知道将控制权转交给哪个区。
分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做"主分区"。
每个主分区的16个字节，由6个部分组成：

```
　  （1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
　　（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
　　（3） 第5个字节：主分区类型。
　　（4） 第6-8个字节：主分区最后一个扇区的物理位置。
　　（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
　　（6） 第13-16字节：主分区的扇区总数。
```

最后的四个字节（"主分区的扇区总数"），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。
如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。

